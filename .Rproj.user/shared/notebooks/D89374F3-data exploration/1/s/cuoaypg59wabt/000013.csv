"0","# Function to apply different smoothing methods"
"0","apply_alpha_smoothing <- function(alpha_data, method = ""ewma"", lambda = 0.94, sma_window = 12) {"
"0","  alpha_data %>%"
"0","    group_by(Currency) %>%"
"0","    arrange(Date) %>%"
"0","    mutate("
"0","      # Exponentially Weighted Moving Average (EWMA)"
"0","      # Based on RiskMetrics methodology (J.P. Morgan, 1996)"
"0","      Alpha_EWMA = case_when("
"0","        method %in% c(""ewma"", ""both"") ~ {"
"0","          alpha_vec <- Alpha"
"0","          alpha_vec[1] <- Alpha[1]  # Initialize with first value"
"0","          for(i in 2:length(alpha_vec)) {"
"0","            if(!is.na(alpha_vec[i-1]) & !is.na(Alpha[i])) {"
"0","              alpha_vec[i] <- lambda * alpha_vec[i-1] + (1 - lambda) * Alpha[i]"
"0","            }"
"0","          }"
"0","          alpha_vec"
"0","        },"
"0","        TRUE ~ Alpha"
"0","      ),"
"0","      "
"0","      # Simple Moving Average (SMA)"
"0","      Alpha_SMA = case_when("
"0","        method %in% c(""sma"", ""both"") ~ rollmean(Alpha, k = sma_window, fill = NA, align = ""right""),"
"0","        TRUE ~ Alpha"
"0","      ),"
"0","      "
"0","      # Adaptive smoothing based on alpha volatility"
"0","      # Higher volatility = more smoothing (Moreira & Muir, 2017)"
"0","      Alpha_Volatility = roll_sd(Alpha, n = 12, fill = NA, align = ""right""),"
"0","      Adaptive_Lambda = pmax(0.8, pmin(0.98, 0.94 + 0.04 * (Alpha_Volatility / max(Alpha_Volatility, na.rm = TRUE)))),"
"0","      "
"0","      Alpha_Adaptive = case_when("
"0","        method %in% c(""adaptive"", ""both"") ~ {"
"0","          alpha_vec <- Alpha"
"0","          lambda_vec <- Adaptive_Lambda"
"0","          alpha_vec[1] <- Alpha[1]"
"0","          for(i in 2:length(alpha_vec)) {"
"0","            if(!is.na(alpha_vec[i-1]) & !is.na(Alpha[i]) & !is.na(lambda_vec[i])) {"
"0","              alpha_vec[i] <- lambda_vec[i] * alpha_vec[i-1] + (1 - lambda_vec[i]) * Alpha[i]"
"0","            }"
"0","          }"
"0","          alpha_vec"
"0","        },"
"0","        TRUE ~ Alpha"
"0","      ),"
"0","      "
"0","      # Select the smoothed alpha based on method"
"0","      Alpha_Smoothed = case_when("
"0","        method == ""ewma"" ~ Alpha_EWMA,"
"0","        method == ""sma"" ~ Alpha_SMA,"
"0","        method == ""adaptive"" ~ Alpha_Adaptive,"
"0","        method == ""both"" ~ (Alpha_EWMA + Alpha_SMA) / 2,"
"0","        TRUE ~ Alpha"
"0","      )"
"0","    ) %>%"
"0","    ungroup()"
"0","}"
"0",""
"0","# Enhanced weight calculation with volatility scaling and turnover control"
"0","calculate_enhanced_weights <- function(alpha_data, returns_data, "
"0","                                     vol_target = 0.10, "
"0","                                     turnover_penalty = 0.002,"
"0","                                     min_weight = 0.05) {"
"0","  "
"0","  # Calculate rolling volatility for each currency (Barroso & Santa-Clara, 2015)"
"0","  returns_vol <- returns_data %>%"
"0","    group_by(Currency) %>%"
"0","    arrange(Date) %>%"
"0","    mutate("
"0","      RollingVol = roll_sd(ExcessReturn, n = 12, fill = NA, align = ""right""),"
"0","      VolAdjReturn = ExcessReturn / pmax(RollingVol, 0.01)  # Volatility-adjusted returns"
"0","    ) %>%"
"0","    ungroup()"
"0","  "
"0","  # Enhanced weight calculation"
"0","  enhanced_weights <- alpha_data %>%"
"0","    left_join(returns_vol, by = c(""Date"", ""Currency"")) %>%"
"0","    group_by(Date) %>%"
"0","    mutate("
"0","      # Original deviation-based signal"
"0","      Deviation = abs(Alpha_Smoothed - 0.5),"
"0","      Direction = ifelse(Alpha_Smoothed < 0.5, ""Long"", ""Short""),"
"0","      "
"0","      # Volatility scaling (Moreira & Muir, 2017)"
"0","      # Scale positions inversely with volatility"
"0","      VolScale = pmin(2, vol_target / pmax(RollingVol, 0.01)),"
"0","      "
"0","      # Enhanced signal strength"
"0","      SignalStrength = Deviation * VolScale,"
"0","      "
"0","      # Raw weights with volatility adjustment"
"0","      RawWeight = ifelse(Direction == ""Long"", SignalStrength, -SignalStrength),"
"0","      "
"0","      # Apply minimum weight threshold to reduce noise"
"0","      RawWeight_Filtered = ifelse(abs(RawWeight) < min_weight, 0, RawWeight),"
"0","      "
"0","      # Normalize weights"
"0","      SumAbs = sum(abs(RawWeight_Filtered), na.rm = TRUE),"
"0","      Weight_Prelim = ifelse(SumAbs > 0, RawWeight_Filtered / SumAbs, 0)"
"0","    ) %>%"
"0","    ungroup() %>%"
"0","    "
"0","    # Turnover control: penalize large weight changes"
"0","    group_by(Currency) %>%"
"0","    arrange(Date) %>%"
"0","    mutate("
"0","      Weight_Lag = lag(Weight_Prelim, default = 0),"
"0","      Weight_Change = abs(Weight_Prelim - Weight_Lag),"
"0","      "
"0","      # Apply turnover penalty (DeMiguel et al., 2009)"
"0","      Turnover_Penalty = ifelse(Weight_Change > turnover_penalty, "
"0","                               Weight_Change * 0.5, 0),"
"0","      "
"0","      # Adjust weights for turnover"
"0","      Weight_Adjusted = Weight_Prelim * (1 - Turnover_Penalty)"
"0","    ) %>%"
"0","    ungroup() %>%"
"0","    "
"0","    # Final normalization"
"0","    group_by(Date) %>%"
"0","    mutate("
"0","      SumAbs_Final = sum(abs(Weight_Adjusted), na.rm = TRUE),"
"0","      Weight = ifelse(SumAbs_Final > 0, Weight_Adjusted / SumAbs_Final, 0)"
"0","    ) %>%"
"0","    ungroup()"
"0","  "
"0","  return(enhanced_weights)"
"0","}"
"0",""
"0","# Helper function to detect data structure and extract returns"
"0","detect_and_extract_returns <- function(data) {"
"0","  # Check if data has YearMonth column (assumed to be date column)"
"0","  date_col <- NULL"
"0","  if (""YearMonth"" %in% names(data)) {"
"0","    date_col <- ""YearMonth"""
"0","  } else if (""Date"" %in% names(data)) {"
"0","    date_col <- ""Date"""
"0","  } else {"
"0","    # Look for date-like columns"
"0","    date_candidates <- names(data)[sapply(data, function(x) inherits(x, c(""Date"", ""POSIXct"", ""POSIXlt"")))]"
"0","    if (length(date_candidates) > 0) {"
"0","      date_col <- date_candidates[1]"
"0","      warning(paste(""Using"", date_col, ""as date column""))"
"0","    } else {"
"0","      stop(""No date column found. Please ensure your data has a Date or YearMonth column."")"
"0","    }"
"0","  }"
"0","  "
"0","  # Look for excess return columns (priority order)"
"0","  excess_cols <- names(data)[grepl(""_excess$"", names(data))]"
"0","  "
"0","  if (length(excess_cols) == 0) {"
"0","    # Look for return columns"
"0","    return_cols <- names(data)[grepl(""_return$|_ret$"", names(data), ignore.case = TRUE)]"
"0","    "
"0","    if (length(return_cols) == 0) {"
"0","      # Try to construct excess returns from spot and forward rates"
"0","      spot_cols <- names(data)[grepl(""^spot_"", names(data))]"
"0","      forward_cols <- names(data)[grepl(""^forward_"", names(data))]"
"0","      "
"0","      if (length(spot_cols) > 0 && length(forward_cols) > 0) {"
"0","        # Extract currency codes"
"0","        spot_currencies <- gsub(""^spot_"", """", spot_cols)"
"0","        forward_currencies <- gsub(""^forward_"", """", forward_cols)"
"0","        common_currencies <- intersect(spot_currencies, forward_currencies)"
"0","        "
"0","        if (length(common_currencies) > 0) {"
"0","          cat(""Constructing excess returns from spot and forward rates for currencies:"", "
"0","              paste(common_currencies, collapse = "", ""), ""\n"")"
"0","          "
"0","          # Construct excess returns: spot_t+1 - forward_t"
"0","          for (curr in common_currencies) {"
"0","            spot_col <- paste0(""spot_"", curr)"
"0","            forward_col <- paste0(""forward_"", curr)"
"0","            spot_t1_col <- paste0(""spot_"", curr, ""_t1"")"
"0","            "
"0","            if (spot_t1_col %in% names(data)) {"
"0","              # Use provided t+1 spot rates"
"0","              data[[paste0(curr, ""_excess"")]] <- data[[spot_t1_col]] - data[[forward_col]]"
"0","            } else {"
"0","              # Use lead of spot rates"
"0","              data[[paste0(curr, ""_excess"")]] <- lead(data[[spot_col]]) - data[[forward_col]]"
"0","            }"
"0","          }"
"0","          excess_cols <- paste0(common_currencies, ""_excess"")"
"0","        } else {"
"0","          stop(""Cannot identify matching spot and forward rate columns to construct excess returns"")"
"0","        }"
"0","      } else {"
"0","        stop(""No excess return columns found and cannot construct them from available data"")"
"0","      }"
"0","    } else {"
"0","      excess_cols <- return_cols"
"0","      cat(""Using return columns:"", paste(return_cols, collapse = "", ""), ""\n"")"
"0","    }"
"0","  }"
"0","  "
"0","  # Create returns dataset"
"0","  returns_data <- data %>%"
"0","    dplyr::select(all_of(c(date_col, excess_cols))) %>%"
"0","    rename(Date = !!date_col) %>%"
"0","    mutate(Date = as.Date(Date))"
"0","  "
"0","  return(list("
"0","    returns_data = returns_data,"
"0","    currencies = gsub(""_excess$|_return$|_ret$"", """", excess_cols, ignore.case = TRUE),"
"0","    excess_cols = excess_cols"
"0","  ))"
"0","}"
"0",""
"0","# Main enhanced portfolio allocation function"
"0","enhanced_alpha_portfolio_allocation <- function(alpha_matrix, returns_data, "
"0","                                              smoothing_method = ""ewma"","
"0","                                              lambda = 0.94,"
"0","                                              sma_window = 12,"
"0","                                              vol_target = 0.10,"
"0","                                              turnover_penalty = 0.002,"
"0","                                              min_weight = 0.05) {"
"0","  "
"0","  # Convert alpha matrix to long format"
"0","  alpha_long <- as.data.frame(alpha_matrix) %>%"
"0","    rownames_to_column(""Date"") %>%"
"0","    pivot_longer(-Date, names_to = ""Currency"", values_to = ""Alpha"") %>%"
"0","    mutate("
"0","      Date = as.Date(Date, format = ""%Y-%m-%d""),"
"0","      Alpha = as.numeric(Alpha)"
"0","    ) %>%"
"0","    filter(!is.na(Alpha))"
"0","  "
"0","  # Apply smoothing"
"0","  alpha_smoothed <- apply_alpha_smoothing(alpha_long, "
"0","                                        method = smoothing_method,"
"0","                                        lambda = lambda,"
"0","                                        sma_window = sma_window)"
"0","  "
"0","  # Detect and extract returns data"
"0","  returns_info <- detect_and_extract_returns(returns_data)"
"0","  "
"0","  # Prepare returns data in long format"
"0","  returns_long <- returns_info$returns_data %>%"
"0","    pivot_longer(-Date, names_to = ""Currency"", values_to = ""ExcessReturn"") %>%"
"0","    mutate(Currency = gsub(""_excess$|_return$|_ret$"", """", Currency, ignore.case = TRUE))"
"0","  "
"0","  # Calculate enhanced weights"
"0","  portfolio_weights <- calculate_enhanced_weights(alpha_smoothed, returns_long,"
"0","                                                vol_target = vol_target,"
"0","                                                turnover_penalty = turnover_penalty,"
"0","                                                min_weight = min_weight)"
"0","  "
"0","  # Calculate portfolio returns with transaction costs"
"0","  alpha_portfolio <- portfolio_weights %>%"
"0","    left_join(returns_long, by = c(""Date"", ""Currency"")) %>%"
"0","    group_by(Date) %>%"
"0","    summarise("
"0","      # Portfolio return before transaction costs"
"0","      PortfolioReturn_Gross = sum(Weight * ExcessReturn, na.rm = TRUE),"
"0","      "
"0","      # Transaction costs (simple model: 0.1% per unit of turnover)"
"0","      TotalTurnover = sum(abs(Weight_Change), na.rm = TRUE) / 2,"
"0","      TransactionCosts = TotalTurnover * 0.001,"
"0","      "
"0","      # Net portfolio return"
"0","      PortfolioReturn = PortfolioReturn_Gross - TransactionCosts,"
"0","      "
"0","      # Additional metrics"
"0","      ActivePositions = sum(abs(Weight) > 0.01, na.rm = TRUE),"
"0","      PortfolioVolatility = sqrt(sum((Weight * ExcessReturn)^2, na.rm = TRUE)),"
"0","      "
"0","      .groups = ""drop"""
"0","    ) %>%"
"0","    arrange(Date) %>%"
"0","    mutate("
"0","      CumulativeReturn = cumprod(1 + PortfolioReturn) - 1,"
"0","      CumulativeReturn_Gross = cumprod(1 + PortfolioReturn_Gross) - 1,"
"0","      "
"0","      # Rolling Sharpe ratio (annualized)"
"0","      RollingReturn = roll_mean(PortfolioReturn, n = 12, fill = NA, align = ""right""),"
"0","      RollingVol = roll_sd(PortfolioReturn, n = 12, fill = NA, align = ""right""),"
"0","      RollingSharpe = (RollingReturn * 12) / (RollingVol * sqrt(12))"
"0","    )"
"0","  "
"0","  # Create summary statistics"
"0","  summary_stats <- alpha_portfolio %>%"
"0","    filter(!is.na(PortfolioReturn)) %>%"
"0","    summarise("
"0","      TotalReturn = tail(CumulativeReturn, 1),"
"0","      AnnualizedReturn = (1 + TotalReturn)^(12/n()) - 1,"
"0","      AnnualizedVol = sd(PortfolioReturn, na.rm = TRUE) * sqrt(12),"
"0","      SharpeRatio = AnnualizedReturn / AnnualizedVol,"
"0","      MaxDrawdown = max(cummax(CumulativeReturn) - CumulativeReturn, na.rm = TRUE),"
"0","      AvgTurnover = mean(TotalTurnover, na.rm = TRUE),"
"0","      AvgTransactionCosts = mean(TransactionCosts, na.rm = TRUE) * 12,"
"0","      .groups = ""drop"""
"0","    )"
"0","  "
"0","  return(list("
"0","    portfolio_returns = alpha_portfolio,"
"0","    portfolio_weights = portfolio_weights,"
"0","    summary_stats = summary_stats"
"0","  ))"
"0","}"
"0",""
"0","# Example usage with different smoothing methods"
"0","# For your specific data structure:"
"0",""
"0","# Method 1: EWMA Smoothing (λ = 0.94, typical for monthly data)"
"0","results_ewma <- enhanced_alpha_portfolio_allocation("
"0","  alpha_matrix = alpha_matrix,"
"0","  returns_data = wide_month,  # Function will auto-detect structure"
"0","  smoothing_method = ""ewma"","
"0","  lambda = 0.94,"
"0","  vol_target = 0.10,"
"0","  turnover_penalty = 0.002"
"0",")"
"1","[1m[33mError[39m in `summarise()`:[22m
[38;5;236m[36mℹ[38;5;236m In argument: `PortfolioReturn_Gross = sum(Weight * ExcessReturn, na.rm = TRUE)`.
[36mℹ[38;5;236m In group 1: `Date = 2005-02-01`.[39m
[1mCaused by error:[22m
[33m![39m object 'ExcessReturn' not found
[90mRun `]8;;x-r-run:rlang::last_trace()rlang::last_trace()]8;;` to see where the error occurred.[39m
"
